package main

import (
	"bytes"
	"flag"
	"fmt"
	"html/template"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
)

var applyFlag bool

func main() {
	flag.BoolVar(&applyFlag, "apply", false, "write to file")
	flag.Parse()

	precompileNames, err := getPrecompileNames()
	if err != nil {
		fmt.Printf("failed to get precompile names: %v\n", err)
		os.Exit(1)
	}

	if err := applyTemplate(precompileNames); err != nil {
		fmt.Printf("failed to apply template: %v\n", err)
		os.Exit(1)
	}
}

var templateFile = `// SPDX-License-Identifier: UNLICENSED
// DO NOT edit this file. Code generated by forge-gen.
pragma solidity ^0.8.8;

import "../suavelib/Suave.sol";

library SuaveAddrs {
	function getSuaveAddrs() external pure returns (address[] memory) {
		address[] memory addrList = new address[]({{ len .PrecompileNames }});
		{{range $indx, $elem := .PrecompileNames}}
		addrList[{{ $indx }}] = Suave.{{ $elem}};
		{{- end}}

		return addrList;
	}
}`

func applyTemplate(precompileNames []string) error {
	t, err := template.New("template").Parse(templateFile)
	if err != nil {
		return err
	}

	input := map[string]interface{}{
		"PrecompileNames": precompileNames,
	}

	var outputRaw bytes.Buffer
	if err = t.Execute(&outputRaw, input); err != nil {
		return err
	}

	str := outputRaw.String()
	if str, err = formatSolidity(str); err != nil {
		return err
	}

	if applyFlag {
		if err := os.WriteFile(resolvePath("../../src/forge/SuaveAddrs.sol"), []byte(str), 0644); err != nil {
			return err
		}
	} else {
		fmt.Println(str)
	}
	return nil
}

func getPrecompileNames() ([]string, error) {
	content, err := os.ReadFile("./src/suavelib/Suave.sol")
	if err != nil {
		return nil, err
	}

	addrRegexp := regexp.MustCompile(`constant\s+([A-Za-z_]\w*)\s+=`)

	matches := addrRegexp.FindAllStringSubmatch(string(content), -1)

	names := []string{}
	for _, match := range matches {
		if len(match) > 1 {
			name := strings.TrimSpace(match[1])
			if name == "ANYALLOWED" {
				continue
			}
			if name == "CONFIDENTIAL_INPUTS" {
				continue
			}
			names = append(names, name)
		}
	}

	return names, nil
}

func formatSolidity(code string) (string, error) {
	return execForgeCommand([]string{"fmt", "--raw", "-"}, code)
}

func execForgeCommand(args []string, stdin string) (string, error) {
	_, err := exec.LookPath("forge")
	if err != nil {
		return "", fmt.Errorf("forge command not found in PATH: %v", err)
	}

	// Create a command to run the forge command
	cmd := exec.Command("forge", args...)

	// Set up input from stdin
	if stdin != "" {
		cmd.Stdin = bytes.NewBufferString(stdin)
	}

	// Set up output buffer
	var outBuf, errBuf bytes.Buffer
	cmd.Stdout = &outBuf
	cmd.Stderr = &errBuf

	// Run the command
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("error running command: %v, %s", err, errBuf.String())
	}

	return outBuf.String(), nil
}

func resolvePath(path string) string {
	// Get the caller's file path.
	_, filename, _, _ := runtime.Caller(1)

	// Resolve the directory of the caller's file.
	callerDir := filepath.Dir(filename)

	// Construct the absolute path to the target file.
	return filepath.Join(callerDir, path)
}
